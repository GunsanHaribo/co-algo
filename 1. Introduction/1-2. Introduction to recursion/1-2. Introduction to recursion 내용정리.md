## 재귀(Recursion)

- 정의: 함수가 자기 자신을 호출해 문제를 해결.
    - 계산 가능성 이론(Computability Theory)에 따르면, 모든 반복 알고리즘은 재귀로 변환 가능
- 핵심:
    - 베이스 케이스: 재귀를 멈추는 조건 (예: `i > n`).
    - 재귀 호출: 문제를 작은 단위로 나눔 (예: `fn(i+1)`).
- 작동: 호출이 쌓이고(스택), 베이스 케이스 후 반환되며 정리.
- 가치: 부분 문제로 나누어 해결 (예: 피보나치 `F(n) = F(n-1) + F(n-2)`)

### 피보나치 수열 콜스택 변화 과정

~~~python
function F(n):
    if (n == 0): return 0  // 베이스 케이스
    if (n == 1): return 1  // 베이스 케이스
    return F(n-1) + F(n-2)
F(3)
~~~

1. 초기 호출: F(4)

~~~text
콜스택:
| F(4) |
--------

- F(4)가 스택에 쌓이고, F(3) + F(2) 계산 시작.
~~~

2. F(3) 호출

~~~text
콜스택:
| F(3) |
| F(4) |
--------

- F(3)이 스택에 추가, F(2) + F(1) 계산 시작.
~~~

2. F(2) 호출

~~~text
콜스택:
| F(2) |
| F(3) |
| F(4) |
--------

- F(2)가 스택에 추가, F(1) + F(0) 계산 시작.
~~~

3. F(1) 호출

~~~text
콜스택:
| F(1) |
| F(2) |
| F(3) |
| F(4) |
--------

- F(1)이 스택에 추가, 베이스 케이스(F(1) = 1)로 즉시 반환.
~~~

4. F(1) 반환

~~~text
콜스택:
| F(2) |
| F(3) |
| F(4) |
--------
값: F(1) = 1

- F(1)이 스택에서 제거, F(2)는 이제 F(0) 호출.
~~~

5. F(0) 호출

~~~text
콜스택:
| F(0) |
| F(2) |
| F(3) |
| F(4) |
--------

- F(0)이 스택에 추가, 베이스 케이스(F(0) = 0)로 즉시 반환.
~~~

6. F(0) 반환

~~~text
콜스택:
| F(2) |
| F(3) |
| F(4) |
--------
값: F(1) = 1, F(0) = 0

- F(0)이 스택에서 제거, F(2)는 F(1) + F(0) = 1 + 0 = 1 계산 후 반환.
~~~

7. F(2) 반환

~~~text
콜스택:
| F(3) |
| F(4) |
--------
값: F(2) = 1

- F(2)가 스택에서 제거, F(3)는 이제 F(1) 호출.
~~~

8. F(1) 호출

~~~text
콜스택:
| F(1) |
| F(3) |
| F(4) |
--------

- F(1)이 스택에 추가, 베이스 케이스(F(1) = 1)로 즉시 반환.
~~~

9. F(1) 반환

~~~text
콜스택:
| F(3) |
| F(4) |
--------
값: F(2) = 1, F(1) = 1

- F(1)이 스택에서 제거, F(3)는 F(2) + F(1) = 1 + 1 = 2 계산 후 반환.
~~~

10. F(3) 반환

~~~text
콜스택:
| F(4) |
--------
값: F(3) = 2

- F(3)이 스택에서 제거, F(4)는 이제 F(2) 호출.
~~~

11. F(2) 호출

~~~text
콜스택:
| F(2) |
| F(4) |
--------

- F(2)가 스택에 추가, F(1) + F(0) 계산 시작.
~~~

12. F(1) 호출

~~~text
콜스택:
| F(1) |
| F(2) |
| F(4) |
--------

- F(1)이 스택에 추가, 베이스 케이스(F(1) = 1)로 즉시 반환.
~~~

13. F(1) 반환
    text

~~~text
콜스택:
| F(2) |
| F(4) |
--------
값: F(1) = 1

- F(1)이 스택에서 제거, F(2)는 이제 F(0) 호출.
~~~

14. F(0) 호출

~~~text
콜스택:
| F(0) |
| F(2) |
| F(4) |
--------

- F(0)이 스택에 추가, 베이스 케이스(F(0) = 0)로 즉시 반환.
~~~

15. F(0) 반환

~~~text
콜스택:
| F(2) |
| F(4) |
--------
값: F(1) = 1, F(0) = 0

- F(0)이 스택에서 제거, F(2)는 F(1) + F(0) = 1 + 0 = 1 계산 후 반환.
~~~

16. F(2) 반환

~~~text
콜스택:
| F(4) |
--------
값: F(3) = 2, F(2) = 1

- F(2)가 스택에서 제거, F(4)는 F(3) + F(2) = 2 + 1 = 3 계산 후 반환.
~~~

17. F(4) 반환

~~~text
콜스택:
| |
--------
최종 값: F(4) = 3

- F(4)가 스택에서 제거, 재귀 종료.
~~~

18. 최종 결과

~~~text
F(4) = 3
~~~

### 설명

- 쌓임(Stack Push): 각 fn(i) 호출은 스택에 쌓이며, 재귀가 깊어질수록 스택이 커짐.
- 정리(Stack Pop): 베이스 케이스 후 함수가 반환되며 스택이 역순으로 비워짐.
- 중복 계산: F(2)가 두 번 계산됨(효율성을 위해 메모이제이션 고려 가능).