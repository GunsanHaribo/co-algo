## 1. 시간 복잡도 (Time Complexity)

시간 복잡도는 알고리즘이 **입력 크기(n)에 따라 연산 횟수가 어떻게 증가**하는지를 분석하는 척도입니다.

#### 1-1. 핵심 개념:

- 알고리즘은 입력 크기(n)가 무한대로 향할 때의 성능을 기준으로 평가됩니다.
- 상수(예: 5n → O(n))는 무시되며, 연산량의 증가 패턴만 고려합니다.

#### 1-2. 주요 시간 복잡도 예시:

- O(n): 연산 횟수가 입력 크기에 선형적으로 증가 (예: 배열을 한 번 순회).
- O(n²): 연산 횟수가 입력 크기의 제곱에 비례 (예: 이중 반복문).
- O(n + m): 두 배열의 길이(n, m)에 따라 선형적으로 증가 (예: 두 배열을 각각 순회).
- O(log n): 매 단계마다 입력 크기가 일정 비율로 줄어듦 (예: 이진 탐색).
- O(n log n): 효율적인 정렬 알고리즘(예: 퀵소트, 병합 정렬)의 일반적인 복잡도.

#### 1-3. 분석 시 고려 사항:

- 최선(Best Case): 가장 이상적인 입력에서의 성능.
- 평균(Average Case): 일반적인 입력에서의 평균 성능.
- 최악(Worst Case): 가장 비효율적인 입력에서의 성능.

보통 최악의 경우를 기준으로 분석하며, 각 경우의 차이점을 설명할 수 있어야 합니다.

#### 1-4. 예시 분석:

- 이중 반복문 (for { for {}}): O(n²). 내부 루프는 n번, 외부 루프도 n번 반복.
- 두 배열 순회 (for arr1 + for arr2): O(n + m). 각 배열을 독립적으로 순회.

### 2. 공간 복잡도 (Space Complexity)

공간 복잡도는 알고리즘이 실행 중 사용하는 **추가 메모리(입력 제외)의 양**을 입력 크기(n)에 따라 분석합니다.

#### 2-1. 주요 공간 복잡도 예시:

- O(1): 상수 공간만 사용 (예: 단일 변수만 추가).
- O(n): 입력 크기에 비례하는 공간 사용 (예: 입력 배열의 일정 비율 크기의 배열 생성).
- O(n·m): 두 변수(n, m)에 비례하는 2차원 배열 생성.

#### 2-2. 예시 분석:

- 단일 변수 사용 (int num): O(1). 입력 크기와 무관.
- 배열 일부 복사 (nums = arr의 1%): O(n/100) → O(n). 상수 비율은 무시.
- 2차원 배열 생성 (grid[n][m]): O(n·m). n × m 크기의 공간 할당.

#### 결론

- 시간 복잡도: 알고리즘 효율성을 평가하며, 입력 크기에 따른 연산 횟수 증가 패턴을 나타냅니다. 최악의 경우를 주로 고려합니다.
- 공간 복잡도: 추가 메모리 사용량을 분석하며, 입력 크기에 따라 증가하는 비율을 측정합니다.
- 복잡도 분석은 알고리즘 설계와 최적화에서 필수적이며, 문제를 풀 때 최선/평균/최악 시나리오를 모두 이해하는 것이 중요합니다.