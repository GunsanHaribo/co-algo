## 투 포인터

- 정의: 두 개의 정수 변수(포인터)를 사용해 배열, 문자열 등 **순회 가능한** 자료를 탐색하는 알고리즘 기법.
    - 다만, 사용은 **시간복잡도 O(n)나 공간 복잡도 O(1)**으로 극한적으로 제한되어있는 상황에 추천
- 키워드
  - 정렬된
  - 특정 쌍, 구간
  - 특정 순서, 패턴[대칭, 순서]
  - 비교, 병합

### 1. 어떤 문제에 사용하면 좋을까?

1. **특정 조건을 만족하는 쌍(pair)이나 구간**를 찾아야 할 때
    - 상황: 데이터에서 **특정 조건을 만족하는 쌍(pair)이나 구간**을 찾아야 하는데, 어디서부터 어디까지 봐야 할지 모를 때.
    - 예시:
        - "배열에서 두 수의 합이 특정 값이 되는 쌍을 찾아라" (예: [1, 2, 3, 4], target=5 → 1+4=5).
        - 왜 유용?: 정렬된 배열이라면, 양 끝에서 시작해 합이 크면 오른쪽 포인터를 줄이고, 작으면 왼쪽 포인터를 늘리며 범위를 좁힐 수 있음.
    - 적용 팁: 데이터가 정렬되어 있지 않다면 먼저 정렬(O(n log n)) 후 적용 가능.


2. **특정 순서나 패턴**을 확인해야 할 때
    - 상황: 문자열이나 배열에서 **특정 순서나 패턴(예: 대칭, 부분 수열)**이 있는지 확인해야 할 때.
    - 예시:
        - "이 문자열이 팰린드롬인가?" (예: "racecar" → true).
        - "문자열 s가 t의 부분 수열인가?" (예: s="abc", t="ahbgdc" → true).
        - 왜 유용?: 두 포인터로 양 끝이나 한 방향으로 이동하며 순서를 점진적으로 확인 가능.
    - 적용 팁: 팰린드롬은 양 끝에서, 부분 수열은 한 방향으로 포인터를 이동.


3. 두 데이터 셋을 **비교하거나 병합**할 때
    - 상황: 두 개의 배열이나 리스트를 비교하거나 합쳐야 하는데, 어떻게 효율적으로 처리할지 모를 때.
    - 예시:
        - "두 정렬된 배열을 병합하라" (예: [1, 3, 5] + [2, 4, 6] → [1, 2, 3, 4, 5, 6]).
        - 왜 유용?: 각 배열에 포인터를 두고 작은 값을 먼저 선택하며 선형 시간에 병합 가능.
    - 적용 팁: 입력이 정렬되어 있어야 최적화 가능.


4. 불필요한 **중첩 반복**을 줄이고 싶을 때(for문 개선)
    - 상황: 모든 요소를 쌍으로 확인하려면 O(n²)이 걸리는데, 더 빠르게 해결하고 싶을 때.
    - 예시:
        - "배열에서 연속된 구간의 합이 특정 값이 되는 경우를 찾아라."
        - 왜 유용?: 두 포인터로 구간을 동적으로 조정하며 O(n)으로 해결 가능.
    - 적용 팁: 슬라이딩 윈도우와 결합해 구간 문제를 풀 때 효과적.

### 2. 언제 사용하면 안될까?

- **데이터가 정렬되지 않았고 정렬할 수 없을 때**: Two Pointers는 주로 정렬된 데이터에 의존.
- **랜덤 액세스가 불가능한 경우**: 연결 리스트처럼 인덱스로 바로 접근할 수 없는 자료구조에서는 비효율적일 수 있음.
- 문제의 조건이 **포인터 이동으로 해결되지 않을 때**: 예를 들어, 그래프 탐색처럼 **비선형 구조**에서는 부적합.

### 3. 주요 구현 방식

1. 양 끝에서 시작

- 설명: 포인터를 배열의 처음(left)과 끝(right)에서 시작해 서로를 향해 이동.
- 사용 예시:
    - 팰린드롬 확인: 문자열의 처음과 끝 문자를 비교하며 이동 (예: "racecar").
    - 두 수의 합 찾기: 정렬된 배열에서 두 수의 합이 타겟과 일치하는지 확인 (예: nums=[3,6,21,23,25], target=27 → 6+21=27).
- 시간 복잡도: O(n), 각 반복에서 포인터가 최소 한 칸씩 이동하므로 최대 n번 반복.
- 동작 원리: 조건에 따라 left++, right--, 또는 둘 다 이동.

2. 두 개의 입력을 동시에 순회

- 설명: 두 개의 배열이나 문자열을 각각 포인터(i, j)로 순회하며 비교.
- 사용 예시:
    - 정렬된 배열 합치기: 두 정렬된 배열을 하나로 병합 (예: arr1과 arr2를 비교하며 작은 값을 결과에 추가).
    - 부분 수열 확인: 문자열 s가 t의 부분 수열인지 확인 (예: s="bc", t="abcd" → true).
- 시간 복잡도: O(n+m), n과 m은 각각 입력 길이.
- 동작 원리: 문제에 따라 i++, j++, 또는 둘 다 이동하며, 한 입력이 끝난 후 나머지를 처리.
